generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  type                String?
  provider            String?
  provider_account_id String?
  refresh_token       String?
  access_token        String?
  expires_at          DateTime?
  token_type          String?
  scope               String?
  id_token            String?
  session_state       String?

  @@unique([provider, provider_account_id])
  @@map("accounts")
}

model User {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  approved_at  DateTime?
  availability String?

  email      String? @unique
  username   String? @unique
  name       String? @db.VarChar(255)
  first_name String? @db.VarChar(255)
  last_name  String? @db.VarChar(255)
  password   String? @db.VarChar(255)
  domain     String? @unique
  avatar     String?

  phone_number  String?
  country       String?
  state         String?
  city          String?
  address       String?
  zip_code      String?
  gender        String?
  date_of_birth DateTime? @db.Date

  // question
  score        Int    @default(0) // The user's score
  correct      Int    @default(0) // The number of correct answers
  wrong        Int    @default(0) // The number of wrong answers
  skipped      Int    @default(0) // The number of skipped answers
  language     String @default("English") // User's language preference
  tts_speed    Int    @default(50) // Text-to-Speech speed
  games_played Int    @default(0) // Total games played

  // billing id. e.g. stripe customer id
  billing_id String?

  type              String?   @default("user")
  email_verified_at DateTime?

  is_two_factor_enabled Int?    @default(0)
  two_factor_secret     String? // secret key for two factor authentication

  accounts                  Account[]
  creator_conversations     Conversation[] @relation("creator")
  participant_conversations Conversation[] @relation("participant")
  receiver_messages         Message[]      @relation("receiver")
  sender_messages           Message[]      @relation("sender")
  receiver_notifications    Notification[] @relation("receiver")
  sender_notifications      Notification[] @relation("sender")

  user_payment_methods UserPaymentMethod[]
  user_settings        UserSetting[]
  ucodes               Ucode[]
  roles                Role[]
  role_users           RoleUser[]
  payment_transactions PaymentTransaction[]
  subscriptions        Subscription[]

  // Game-related relations
  created_games           Game[]         @relation("game_creator") // Games created by this user
  game_players            GamePlayer[] // Games this user is playing in
  selected_game_questions GameQuestion[] // Questions selected by this user in Grid Style games

  @@map("users")
}

model Ucode {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
  status     Int?     @default(1) @db.SmallInt

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  token      String?
  email      String?
  expired_at DateTime?

  @@map("ucodes")
}

model Role {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  title  String?
  name   String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  permission_roles PermissionRole[]
  role_users       RoleUser[]
  permissions      Permission[]     @relation("PermissionToRole")

  @@map("roles")
}

model Permission {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  title      String?
  action     String?
  subject    String?
  conditions String?
  fields     String?

  permission_roles PermissionRole[]
  roles            Role[]           @relation("PermissionToRole")

  @@map("permissions")
}

model PermissionRole {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  permission_id String
  permission    Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade)

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  @@id([permission_id, role_id])
  @@map("permission_roles")
}

model RoleUser {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([role_id, user_id])
  @@map("role_users")
}

// this table stores notification event
model NotificationEvent {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  type   String?
  text   String?

  notifications Notification[]

  @@map("notification_events")
}

model Notification {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  read_at DateTime?

  status Int? @default(1) @db.SmallInt

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  notification_event_id String?
  notification_event    NotificationEvent? @relation(fields: [notification_event_id], references: [id])

  entity_id String?

  @@map("notifications")
}

model UserPaymentMethod {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  payment_method_id String?
  checkout_id       String?

  @@map("user_payment_methods")
}

model PaymentTransaction {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  store_id String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  order_id String?

  subscription_id String?
  subscription    Subscription? @relation(fields: [subscription_id], references: [id])

  type             String?  @default("order")
  withdraw_via     String?  @default("wallet")
  provider         String?
  reference_number String?
  status           String?  @default("pending")
  raw_status       String?
  amount           Decimal?
  currency         String?
  paid_amount      Decimal?
  paid_currency    String?

  @@map("payment_transactions")
}

// ---------Start Chat schema---------

enum MessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
}

// message is used for conversation
model Message {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status MessageStatus? @default(PENDING)

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  conversation_id String?
  conversation    Conversation? @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  attachment_id String?
  attachment    Attachment? @relation(fields: [attachment_id], references: [id])

  message String?

  @@map("messages")
}

// this table stores attachment of message
model Attachment {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name     String?
  type     String?
  size     Int?
  file     String?
  file_alt String?

  messages Message[]

  @@map("attachments")
}

// this table stores conversation
model Conversation {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  creator_id String?
  creator    User?   @relation("creator", fields: [creator_id], references: [id])

  participant_id String?
  participant    User?   @relation("participant", fields: [participant_id], references: [id])

  messages Message[]

  @@map("conversations")
}

// ---------End Chat schema---------

model Faq {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  sort_order Int?    @default(0)
  question   String?
  answer     String?

  @@map("faqs")
}

model Contact {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  first_name   String?
  last_name    String?
  email        String?
  phone_number String?
  message      String?

  @@map("contacts")
}

model SocialMedia {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  sort_order Int?    @default(0)
  name       String?
  url        String?
  icon       String?

  @@map("social_medias")
}

model WebsiteInfo {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name                String?
  phone_number        String?
  email               String?
  address             String?
  logo                String?
  favicon             String?
  copyright           String?
  cancellation_policy String?

  @@map("website_infos")
}

model Setting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  category      String?
  label         String?
  description   String?
  key           String? @unique
  default_value String?

  user_settings UserSetting[]

  @@map("settings")
}

model UserSetting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  setting_id String?
  setting    Setting? @relation(fields: [setting_id], references: [id])

  value String?

  @@map("user_settings")
}

// this table stores example
// model Note {
//   id                String  @id @default(cuid())
//   created_at DateTime  @default(now())
//   updated_at DateTime  @default(now())
//   deleted_at DateTime?
//   status     Int?      @default(1) @db.SmallInt

//   title String?
//   body  String? @db.Text

//   tenant_id Int?
//   tenant    Organization? @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
//   @@map("posts")
// }

model Subscription {
  id         String   @id @default(cuid()) // Unique identifier for subscription
  user_id    String // Foreign key for the User
  type       String // e.g., Premium, Standard, Platinum
  games      Int // Number of games allowed
  questions  Int // Number of questions allowed
  players    Int // Number of players allowed
  price      Float // Price of the subscription
  startDate  DateTime
  endDate    DateTime
  status     String // e.g., active, expired
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user                 User                 @relation(fields: [user_id], references: [id], onDelete: Cascade) // Relation with User
  payment_transactions PaymentTransaction[]

  @@map("subscriptions") // Table name in database
}

model Language {
  id         String   @id @default(cuid()) // Unique identifier for the language
  name       String // e.g., English, Arabic
  code       String // e.g., en, ar
  file_url   String? // The language file url
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  categories     Category[]
  question_types QuestionType[]
  difficulties   Difficulty[]
  questions      Question[]
  games          Game[] // Games that use this language

  @@map("languages") // Table name in database
}

model Category {
  id          String   @id @default(cuid()) // Unique identifier for category
  name        String // e.g., Science, History
  language_id String // Foreign key to Language model
  image       String? // Image for the category (optional)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  language  Language   @relation(fields: [language_id], references: [id], onDelete: Cascade) // Relation with Language model
  questions Question[] // Related questions
  games     Game[] // Games that use this category (Quick Game mode)

  @@map("categories") // Table name in database
}

model Difficulty {
  id          String   @id @default(cuid()) // Unique identifier for difficulty level
  name        String // e.g., Easy, Medium, Extreme
  language_id String // Foreign key to Language model
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  language  Language   @relation(fields: [language_id], references: [id], onDelete: Cascade) // Relation with Language model
  questions Question[] // Related questions of this difficulty level

  @@map("difficulties") // Table name in database
}

model QuestionType {
  id          String   @id @default(cuid()) // Unique identifier for the question type
  name        String // Name of the question type (e.g., Multiple Choice, True/False)
  language_id String // Foreign key to the Language model
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  language  Language   @relation(fields: [language_id], references: [id], onDelete: Cascade) // Relation with Language model
  questions Question[] // Related questions of this type

  @@map("question_types") // Table name in the database
}

model Question {
  id               String   @id @default(cuid()) // Unique identifier for the question
  text             String // The question text
  category_id      String // Foreign key to Category model
  language_id      String // Foreign key to Language model
  difficulty_id    String // Foreign key to Difficulty model
  question_type_id String // Foreign key to QuestionType model
  file_url         String? // Optional file upload (e.g., image, document)
  time             Int // Time limit for answering the question (in seconds)
  free_bundle      Boolean // Whether this question is part of a free bundle (Yes/No)
  firebase         Boolean // Whether this question is stored in Firebase (Yes/No)
  points           Int // Points awarded based on difficulty of the question
  created_at       DateTime @default(now()) // Automatically sets the creation date
  updated_at       DateTime @updatedAt // Automatically updates the last modified date

  category       Category       @relation(fields: [category_id], references: [id], onDelete: Cascade) // Relation with Category model
  language       Language       @relation(fields: [language_id], references: [id], onDelete: Cascade) // Relation with Language model
  difficulty     Difficulty     @relation(fields: [difficulty_id], references: [id], onDelete: Cascade) // Relation with Difficulty model
  question_type  QuestionType   @relation(fields: [question_type_id], references: [id], onDelete: Cascade) // Relation with QuestionType model
  answers        Answer[] // Related answers to the question
  game_questions GameQuestion[] // Game instances where this question was used
  game_answers   GameAnswer[] // Game answers for this question

  @@map("questions") // Table name in database
}

model Answer {
  id          String  @id @default(cuid()) // Unique identifier for each answer
  question_id String // Foreign key to Question model
  text        String? // The answer text
  file_url    String? // The answer file url
  is_correct  Boolean @default(false) // Whether the answer is correct or not

  question     Question     @relation(fields: [question_id], references: [id], onDelete: Cascade) // Relation with Question model
  game_answers GameAnswer[] // Related game answers

  @@map("answers") // Table name in database
}

// ---------Start Game schema---------

enum GameMode {
  QUICK_GAME
  GRID_STYLE
}

enum GameStatus {
  WAITING // Waiting for players to join
  IN_PROGRESS // Game is currently being played
  COMPLETED // Game has finished
  CANCELLED // Game was cancelled
}

model Game {
  id         String    @id @default(cuid()) // Unique identifier for the game
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  mode   GameMode   @default(QUICK_GAME) // Game mode: Quick Game or Grid Style
  status GameStatus @default(WAITING) // Current status of the game

  // Game settings
  max_players       Int  @default(8) // Maximum number of players (up to 4)
  question_count    Int? // Number of questions for Quick Game (10-15), null for Grid Style
  time_per_question Int? // Time limit per question in seconds

  // For Quick Game - selected category
  category_id String? // Foreign key to Category model (for Quick Game mode)
  category    Category? @relation(fields: [category_id], references: [id])

  // For Grid Style - all categories are available, no specific category selected
  language_id String // Foreign key to Language model (game language)
  language    Language @relation(fields: [language_id], references: [id])

  // Creator of the game
  creator_id String
  creator    User   @relation("game_creator", fields: [creator_id], references: [id])

  // Relations
  game_players   GamePlayer[] // Players in this game
  game_questions GameQuestion[] // Questions used in this game
  game_answers   GameAnswer[] // All answers given in this game

  @@map("games") // Table name in database
}

model GamePlayer {
  id         String   @id @default(cuid()) // Unique identifier
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  game_id String
  game    Game   @relation(fields: [game_id], references: [id], onDelete: Cascade)

  user_id String
  user    User   @relation(fields: [user_id], references: [id])

  // Player stats for this game
  score           Int @default(0) // Total points earned in this game
  correct_answers Int @default(0) // Number of correct answers
  wrong_answers   Int @default(0) // Number of wrong answers
  skipped_answers Int @default(0) // Number of skipped answers

  // Player position and turn order
  player_order Int // Order in which player joined (1, 2, 3, 4)
  final_rank   Int? // Final ranking when game ends (1st, 2nd, 3rd, 4th)

  // Game answers by this player
  game_answers GameAnswer[]

  @@unique([game_id, user_id]) // A user can only be in a game once
  @@unique([game_id, player_order]) // Each position in a game is unique
  @@map("game_players") // Table name in database
}

model GameQuestion {
  id         String   @id @default(cuid()) // Unique identifier
  created_at DateTime @default(now())

  game_id String
  game    Game   @relation(fields: [game_id], references: [id], onDelete: Cascade)

  question_id String
  question    Question @relation(fields: [question_id], references: [id])

  // Question order in the game
  question_order Int // Order of this question in the game (1, 2, 3, etc.)

  // For Grid Style - which player selected this question
  selected_by_player_id String? // ID of player who selected this question (Grid Style only)
  selected_by_player    User?   @relation(fields: [selected_by_player_id], references: [id])

  // Points available for this question (based on difficulty)
  points_available Int // Points that can be earned for correct answer

  // Timing
  time_limit   Int? // Time limit for this specific question (seconds)
  started_at   DateTime? // When this question was presented
  completed_at DateTime? // When all players finished answering

  // Game answers for this question
  game_answers GameAnswer[]

  @@unique([game_id, question_order]) // Each question order in a game is unique
  @@map("game_questions") // Table name in database
}

model GameAnswer {
  id         String   @id @default(cuid()) // Unique identifier
  created_at DateTime @default(now())

  game_id String
  game    Game   @relation(fields: [game_id], references: [id], onDelete: Cascade)

  game_player_id String
  game_player    GamePlayer @relation(fields: [game_player_id], references: [id], onDelete: Cascade)

  game_question_id String
  game_question    GameQuestion @relation(fields: [game_question_id], references: [id], onDelete: Cascade)

  question_id String
  question    Question @relation(fields: [question_id], references: [id])

  // Player's answer
  selected_answer_id String? // ID of the answer the player selected
  selected_answer    Answer? @relation(fields: [selected_answer_id], references: [id])

  // Answer details
  is_correct    Boolean @default(false) // Whether the answer was correct
  points_earned Int     @default(0) // Points earned for this answer
  time_taken    Int? // Time taken to answer (in seconds)

  // Answer status
  is_skipped  Boolean   @default(false) // Whether the player skipped this question
  answered_at DateTime? // When the player submitted their answer

  @@unique([game_player_id, game_question_id]) // A player can only answer each question once
  @@map("game_answers") // Table name in database
}

// ---------End Game schema---------
